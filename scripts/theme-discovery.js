#!/usr/bin/env node

/**
 * HAXcms Theme Discovery Script
 * 
 * This script discovers all HAXcms themes in the webcomponents repository
 * by looking for classes that extend HAXCMSLitElementTheme and generates
 * a theme registry JSON file compatible with the HAXcms-php themes.json format.
 * 
 * The script will output to elements/haxcms-elements/lib/themes.json
 */

import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import globCallback from 'glob';
const glob = promisify(globCallback);

// Tags that should never surface as user-facing categories
const BANNED_TAGS = new Set(['Blank', 'Personal', 'Module']);

// Thumbnail paths using bare import style that can be resolved by basePath
// Screenshots will be generated by the Puppeteer automation after themes.json is created
function generateThumbnailPath(elementName) {
  return `@haxtheweb/haxcms-elements/lib/theme-screenshots/theme-${elementName}-thumb.jpg`;
}

/**
 * Extract the theme name from a filename or class name
 */
function extractThemeName(content, filename) {
  // Look for static get tag() methods FIRST (most reliable)
  const tagMatch = content.match(/static\s+get\s+tag\(\)\s*{\s*return\s+['"`]([a-z-]+)['"`]/);
  if (tagMatch) {
    return tagMatch[1];
  }
  
  // Look for customElements.define calls
  const defineMatch = content.match(/customElements\.define\(['"`]([a-z-]+)['"`]/);
  if (defineMatch) {
    return defineMatch[1];
  }
  
  // Look for explicit theme name in comments or JSDoc (less reliable)
  const nameMatch = content.match(/@element\s+([a-z-]+)/);
  if (nameMatch) {
    return nameMatch[1];
  }
  
  // Fallback to filename
  const baseName = path.basename(filename, '.js');
  return baseName;
}

/**
 * Extract display name from content or generate from element name
 */
function extractDisplayName(content, elementName) {
  // Look for JSDoc description or title
  const titleMatch = content.match(/@title\s+([^\n]+)/i);
  if (titleMatch) {
    return titleMatch[1].trim();
  }
  
  // Look for short description in comments (limit to reasonable length)
  const descMatch = content.match(/`([^`]{1,100}theme[^`]{0,20})`/i);
  if (descMatch) {
    return descMatch[1];
  }
  
  // Look for class name comments (with length limits)
  const classMatch = content.match(/\/\*\*\s*\n\s*\*\s*([^\n]{1,100})\s*\n/);
  if (classMatch && classMatch[1].toLowerCase().includes('theme')) {
    return classMatch[1];
  }
  
  // Generate Title Case from element name (dash-case to Title Case)
  // Example: "clean-portfolio-theme" -> "Clean Portfolio Theme"
  return elementName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Generate description for blank use case from theme name
 */
function generateBlankDescription(displayName) {
  return `Start with a blank site using the ${displayName}`;
}

/**
 * Determine if a theme should be hidden from user selection
 * These are system or debugging themes that shouldn't appear in use case dashboard
 */
function shouldHideTheme(elementName) {
  const hiddenThemes = [
    'haxcms-json-theme',
    'haxcms-blank-theme', 
    'haxcms-print-theme'
  ];
  return hiddenThemes.includes(elementName);
}

/**
 * Determine if a theme is a terrible theme (intentionally bad design)
 */
function isTerribleTheme(elementName) {
  return elementName.includes('terrible');
}

/**
 * Generate thumbnail path for a theme (will be created by Puppeteer automation)
 */
function getThumbnailPath(elementName) {
  return generateThumbnailPath(elementName);
}

/**
 * Extract theme categories from JSDoc or infer from element name.
 * Ensures we never emit banned tags like "Blank", "Personal", or "Module".
 */
function extractThemeCategories(content, elementName) {
  // 1. Docblock override: @haxcms-theme-category Course, Website
  const catMatch = content.match(/@haxcms-theme-category\s+([^\n]+)/i);
  if (catMatch) {
    return catMatch[1]
      .split(',')
      .map((t) => t.trim())
      .filter((t) => t && !BANNED_TAGS.has(t));
  }

  return ['Website'];
}

/**
 * Determine if a theme should be hidden from selection based on JSDoc.
 * Internal themes stay in themes.json but are not shown in the v2 picker.
 */
function extractThemeHidden(content, elementName) {
  const hiddenMatch = content.match(/@haxcms-theme-internal\s+(true|false)/i);
  if (hiddenMatch) {
    return hiddenMatch[1].toLowerCase() === 'true';
  }
  return shouldHideTheme(elementName);
}

/**
 * Generate the NPM path for the theme
 */
function generateNpmPath(filePath, elementName) {
  // Convert file path to NPM path format
  const relativePath = filePath.replace('./elements/', '');
  const packageName = relativePath.split('/')[0];
  
  // Check if it's in a lib subdirectory
  if (relativePath.includes('/lib/')) {
    return `@haxtheweb/${packageName}/lib/${elementName}.js`;
  } else {
    return `@haxtheweb/${packageName}/${elementName}.js`;
  }
}

/**
 * Check if file contains direct HAXCMSLitElementTheme extension
 */
function isDirectHAXcmsTheme(content) {
  return content.includes('HAXCMSLitElementTheme') || 
         content.includes('extends DDDSuper(HAXCMSLitElementTheme)') ||
         content.includes('extends HAXCMSLitElementTheme');
}

/**
 * Extract the class name that this theme extends
 */
function getExtendedClassName(content) {
  // Look for 'extends ClassName' pattern
  const extendMatch = content.match(/class\s+\w+\s+extends\s+([\w()]+)/);
  if (extendMatch) {
    // Handle patterns like DDDSuper(HAXCMSLitElementTheme) by extracting the base class
    const extendedClass = extendMatch[1];
    if (extendedClass.includes('(') && extendedClass.includes(')')) {
      const innerMatch = extendedClass.match(/\(([^)]+)\)/);
      return innerMatch ? innerMatch[1] : extendedClass;
    }
    return extendedClass;
  }
  return null;
}

/**
 * Check if file extends a known theme class
 */
function extendsThemeClass(content, knownThemeClasses) {
  const extendedClass = getExtendedClassName(content);
  return extendedClass && knownThemeClasses.has(extendedClass);
}

/**
 * Check if a theme should be skipped based on exclusion rules
 */
function shouldSkipTheme(elementName, filePath) {
  // Exclude specific theme names (not real themes or base classes)
  const excludedNames = [
    'AppHaxStore', 
    'custom.es6', 
    'custom-journey-theme',
    'HAXCMSLitElementTheme', // Base class, not a theme
    'haxcms-basic-theme', // Internal basic theme
    'haxcms-slide-theme', // Internal slide theme
    'haxcms-dev-theme', // Development theme
    'simple-colors-shared-styles' // Shared styles, not a theme
  ];
  if (excludedNames.includes(elementName)) {
    return true;
  }
  
  // Exclude themes with 'example' in the file path
  if (filePath.includes('example')) {
    return true;
  }
  
  // Exclude test files - any file with '.test' in the name
  if (filePath.includes('.test') || elementName.includes('.test')) {
    return true;
  }
  
  return false;
}

/**
 * Main theme discovery function with multi-pass inheritance detection
 */
async function discoverThemes() {
  console.log('üîç Discovering HAXcms themes...');
  
  const themes = {};
  const knownThemeClasses = new Set(['HAXCMSLitElementTheme']);
  const fileContentMap = new Map();
  
  try {
    // Find all JavaScript files in elements directory
    const files = await glob('./elements/**/*.js', { 
      ignore: [
        './elements/**/demo/**',
        './elements/**/test/**', 
        './elements/**/node_modules/**',
        './elements/**/lib/**/*.haxProperties.json',
        './elements/**/*.test.js'
      ]
    });
    
    console.log(`üìÅ Scanning ${files.length} JavaScript files...`);
    
    // First pass: Load all file contents and find direct HAXcms themes
    console.log('üîÑ Pass 1: Finding direct HAXcms themes...');
    
    for (const file of files) {
      try {
        const content = fs.readFileSync(file, 'utf8');
        fileContentMap.set(file, content);
        
        // Check if this file contains a direct HAXcms theme
        if (isDirectHAXcmsTheme(content)) {
          const elementName = extractThemeName(content, file);
          
          // Skip excluded themes
          if (shouldSkipTheme(elementName, file)) {
            console.log(`‚è≠Ô∏è  Skipping excluded theme: ${elementName}`);
            continue;
          }
          
          const displayName = extractDisplayName(content, elementName);
          const thumbnail = getThumbnailPath(elementName);
          const npmPath = generateNpmPath(file, elementName);
          const categories = extractThemeCategories(content, elementName);
          const hidden = extractThemeHidden(content, elementName);
          
          themes[elementName] = {
            element: elementName,
            path: npmPath,
            name: displayName,
            thumbnail: thumbnail,
            description: generateBlankDescription(displayName),
            category: categories,
            hidden: hidden,
            terrible: isTerribleTheme(elementName)
          };
          
          // Extract the class name from the content for inheritance tracking
          const classMatch = content.match(/class\s+(\w+)\s+extends/);
          if (classMatch) {
            knownThemeClasses.add(classMatch[1]);
          }
          
          console.log(`‚úÖ Found direct theme: ${elementName} (${displayName})`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Error processing file ${file}: ${error.message}`);
      }
    }
    
    // Multi-pass inheritance detection: keep looking for themes that extend discovered themes
    let passNumber = 2;
    let foundNewThemes = true;
    
    while (foundNewThemes) {
      foundNewThemes = false;
      console.log(`üîÑ Pass ${passNumber}: Finding themes that inherit from discovered themes...`);
      
      for (const [file, content] of fileContentMap) {
        const elementName = extractThemeName(content, file);
        
        // Skip if we already found this theme or it should be excluded
        if (themes[elementName] || shouldSkipTheme(elementName, file)) {
          continue;
        }
        
        // Check if this theme extends any known theme classes
        if (extendsThemeClass(content, knownThemeClasses)) {
          const displayName = extractDisplayName(content, elementName);
          const thumbnail = getThumbnailPath(elementName);
          const npmPath = generateNpmPath(file, elementName);
          const categories = extractThemeCategories(content, elementName);
          const hidden = extractThemeHidden(content, elementName);
          
          themes[elementName] = {
            element: elementName,
            path: npmPath,
            name: displayName,
            thumbnail: thumbnail,
            description: generateBlankDescription(displayName),
            category: categories,
            hidden: hidden,
            terrible: isTerribleTheme(elementName)
          };
          
          // Extract the class name for future inheritance tracking
          const classMatch = content.match(/class\s+(\w+)\s+extends/);
          if (classMatch) {
            knownThemeClasses.add(classMatch[1]);
          }
          
          console.log(`‚úÖ Found inherited theme: ${elementName} (${displayName})`);
          foundNewThemes = true;
        }
      }
      
      passNumber++;
      
      // Safety check to prevent infinite loops
      if (passNumber > 10) {
        console.warn('‚ö†Ô∏è  Stopped inheritance detection after 10 passes to prevent infinite loops');
        break;
      }
    }
    
    console.log(`üé® Discovered ${Object.keys(themes).length} themes`);
    
    // Sort themes alphabetically by element name (case-insensitive)
    const sortedThemes = Object.keys(themes)
      .sort((a, b) => a.localeCompare(b))
      .reduce((sorted, key) => {
        sorted[key] = themes[key];
        return sorted;
      }, {});
    
    // Ensure output directory exists
    const outputDir = './elements/haxcms-elements/lib';
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write themes.json file
    const outputPath = path.join(outputDir, 'themes.json');
    fs.writeFileSync(outputPath, JSON.stringify(sortedThemes, null, 2));
    
    console.log(`üìÑ Theme registry written to: ${outputPath}`);
    
    // Sync themes.json to both HAXcms platforms using relative paths
    try {
      const nodejsPath = '../haxcms-nodejs/src/coreConfig/themes.json';
      const phpPath = '../haxcms-php/system/coreConfig/themes.json';
      
      // Copy to Node.js platform
      fs.writeFileSync(nodejsPath, JSON.stringify(sortedThemes, null, 2));
      console.log(`üîÑ Synced themes.json to HAXcms Node.js: ${nodejsPath}`);
      
      // Copy to PHP platform
      fs.writeFileSync(phpPath, JSON.stringify(sortedThemes, null, 2));
      console.log(`üîÑ Synced themes.json to HAXcms PHP: ${phpPath}`);
      
    } catch (syncError) {
      console.warn(`‚ö†Ô∏è  Warning: Could not sync themes.json to platforms: ${syncError.message}`);
    }
    
    console.log('üéâ Theme discovery and platform sync completed successfully!');
    
    return themes;
    
  } catch (error) {
    console.error('‚ùå Error during theme discovery:', error);
    process.exit(1);
  }
}

// Run the script if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  discoverThemes().catch(error => {
    console.error('‚ùå Fatal error:', error);
    process.exit(1);
  });
}

export default discoverThemes;
