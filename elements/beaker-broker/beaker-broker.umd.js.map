{"version":3,"file":"beaker-broker.umd.js","sources":["beaker-broker.umd.js"],"sourcesContent":["/**\n * Copyright 2018 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { LitElement, html, css } from \"lit-element/lit-element.js\";\n\n/**\n * `beaker-broker`\n * `An element to help check for and broker calls to read and write beaker browser dat sites.\n * This allows for data binding and figuring out if we're in an environment that we can even use this.`\n *\n * @microcopy - language worth noting:\n *  - beaker browser - a transformative, decentralized platform\n *  - dat - a communication protocol for serving sites up p2p\n *\n * @demo demo/index.html\n * @customElement beaker-broker\n */\nclass BeakerBroker extends LitElement {\n  \n  // render function\n  render() {\n    return html`\n<style>\n:host {\n  display: block;\n}\n\n:host([hidden]) {\n  display: none;\n}\n        </style>\n<slot></slot>`;\n  }\n\n  // haxProperty definition\n  static get haxProperties() {\n    return {}\n;\n  }\n  // properties available to the custom element for data binding\n    static get properties() {\n    return {\n  \n  ...super.properties,\n  \n  /**\n   * Archive\n   */\n  \"archive\": {\n    \"type\": Object\n  },\n  /**\n   * datUrl\n   */\n  \"datUrl\": {\n    \"type\": String,\n    \"attribute\": \"dat-url\"\n  }\n}\n;\n  }\n\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   * @notice function name must be here for tooling to operate correctly\n   */\n  static get tag() {\n    return \"beaker-broker\";\n  }\n  /**\n   * LitElement ready\n   */\n  firstUpdated() {\n    if (typeof DatArchive === typeof undefined) {\n      console.log(\"Beaker is not available from this site loading methodology\");\n    }\n  }\n  /**\n   * HTMLElement\n   */\n  constructor() {\n    super();\n    this.datUrl = window.location.host;\n  }\n  /**\n   * LitElement properties changed\n   */\n  updated(changedProperties) {\n    changedProperties.forEach((oldValue, propName) => {\n      if (propName == \"archive\") {\n        // notify\n        this.dispatchEvent(\n          new CustomEvent(\"archive-changed\", {\n            detail: {\n              value: this[propName]\n            }\n          })\n        );\n      }\n      if (propName == \"datUrl\") {\n        this._datUrlChanged(this[propName]);\n        // notify\n        this.dispatchEvent(\n          new CustomEvent(\"dat-url-changed\", {\n            detail: {\n              value: this[propName]\n            }\n          })\n        );\n      }\n    });\n  }\n  /**\n   * notice dat address has changed, build the object for it\n   */\n  async _datUrlChanged(newValue) {\n    if (typeof DatArchive !== typeof undefined && newValue) {\n      // load current site, set to archive\n      this.archive = new DatArchive(newValue);\n    }\n  }\n\n  /**\n   * Write to file\n   * @usage - this.write('hello.txt', 'things and stuff');\n   */\n  async write(path, data) {\n    // well that was easy\n    await this.archive.writeFile(path, data);\n  }\n\n  /**\n   * Read to file\n   * @var path - location of file\n   * @var type - utf8, base64, hex, binary or specialized ones jpeg / png\n   * @return Promise() with reference to the data in the file if await / async is active\n   * @usage - await this.read('index.html'); to get this file\n   */\n  async read(path, type) {\n    var ftype = \"utf8\";\n    var response;\n    // special cases for image types\n    switch (type) {\n      case \"jpeg\":\n      case \"jpg\":\n        ftype = \"binary\";\n        var buf = await this.archive.readFile(path, ftype);\n        var blob = new Blob([buf], { type: \"image/jpeg\" });\n        response = URL.createObjectURL(blob);\n        break;\n      case \"png\":\n        ftype = \"binary\";\n        var buf = await this.archive.readFile(path, ftype);\n        var blob = new Blob([buf], { type: \"image/png\" });\n        response = URL.createObjectURL(blob);\n        break;\n      case \"base64\":\n        var str = await this.archive.readFile(path, type);\n        response = \"data:image/png;base64,\" + str;\n        break;\n      default:\n        var str = await this.archive.readFile(path, type);\n        response = str;\n        break;\n    }\n    return await response;\n  }\n}\nwindow.customElements.define(BeakerBroker.tag, BeakerBroker);\nexport { BeakerBroker };\n"],"names":["BeakerBroker","datUrl","window","location","host","LitElement","html","DatArchive","console","log","Object","String","changedProperties","forEach","oldValue","propName","_this2","dispatchEvent","CustomEvent","detail","value","_datUrlChanged","newValue","archive","path","data","this","writeFile","type","ftype","readFile","buf","blob","Blob","response","URL","createObjectURL","str","customElements","define","tag"],"mappings":"w0EAkBMA,yKAiEGC,OAASC,OAAOC,SAASC,mPAjEPC,yDAIhBC,sFAoDIC,yBAAAA,cACTC,QAAQC,IAAI,4GAtCP,+aAYE,MACDC,eAKA,MACAC,iBACK,+CAWN,uDAoBDC,cACNA,EAAkBC,QAAQ,SAACC,EAAUC,GACnB,WAAZA,GAEFC,EAAKC,cACH,IAAIC,YAAY,kBAAmB,CACjCC,OAAQ,CACNC,MAAOJ,EAAKD,OAKJ,UAAZA,IACFC,EAAKK,eAAeL,EAAKD,IAEzBC,EAAKC,cACH,IAAIC,YAAY,kBAAmB,CACjCC,OAAQ,CACNC,MAAOJ,EAAKD,8FAUHO,qHACRf,yBAAAA,cAAmCe,SAEvCC,QAAU,IAAIhB,WAAWe,kLAQtBE,EAAMC,kGAEVC,KAAKH,QAAQI,UAAUH,EAAMC,kLAU1BD,EAAMI,gGACXC,EAAQ,YAGJD,SACD,gBACA,eAMA,gBAMA,0CAXHC,EAAQ,kBACQH,KAAKH,QAAQO,SAASN,EAAMK,iBAAxCE,SACAC,EAAO,IAAIC,KAAK,CAACF,GAAM,CAAEH,KAAM,eACnCM,EAAWC,IAAIC,gBAAgBJ,uCAG/BH,EAAQ,mBACQH,KAAKH,QAAQO,SAASN,EAAMK,kBAAxCE,SACAC,EAAO,IAAIC,KAAK,CAACF,GAAM,CAAEH,KAAM,cACnCM,EAAWC,IAAIC,gBAAgBJ,iDAGfN,KAAKH,QAAQO,SAASN,EAAMI,kBAAxCS,SACJH,EAAW,yBAA2BG,gDAGtBX,KAAKH,QAAQO,SAASN,EAAMI,kBAAxCS,SACJH,EAAWG,gDAGFH,0JAGjBhC,OAAOoC,eAAeC,OAAOvC,EAAawC,IAAKxC"}